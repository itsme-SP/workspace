/*
 * stm32f401xx.h
 *
 *  Created on: Aug 6, 2025
 *      Author: Shivaprasad
 */

#ifndef INC_STM32F401XX_H_
#define INC_STM32F401XX_H_
#include <stdint.h>
#include <string.h>
#define __vo volatile
/****************************Processor Specific Details*************************************************
 *
 *ARM CORTEX M4 Processor NVIC ISERx(Interrupt Set Enable Rregister) Register addresses
 *ARM when the ISER register is 1 it will enable  intterupt that will be set by the user
 */
#define NVIC_ISER0_BASE_ADDRESS ((__vo uint32_t*)0xE000E100) // ISER 0 ranges from 0  to 31
#define NVIC_ISER1_BASE_ADDRESS ((__vo uint32_t*)0xE000E104) // ISER 1 ranges from 32 to 64
#define NVIC_ISER2_BASE_ADDRESS ((__vo uint32_t*)0xE000E108) // ISER 2 ranges from 65 to 96

/*
 * ARM CORTEX M4 Processor NVIC ICERx(Interrupt clear Enable Register) Register addresses
 * when the ICER register is 1 it will disable the current intterupt that will be running in that vector table
 */
#define NVIC_ICER0_BASE_ADDRESS ((__vo uint32_t*)0XE000E180) // ICER 0 ranges from 0 to 31
#define NVIC_ICER1_BASE_ADDRESS ((__vo uint32_t*)0XE000E184) // ICER 1 ranges from 32 to 64
#define NVIC_ICER2_BASE_ADDRESS ((__vo uint32_t*)0XE000E188) // ICER 2 ranges from 65 to 96

/*
 * ARM CORTEX M4 Processor NVIC Interrupt priority register base address
 */
#define NVIC_IPR_BASE_ADDRESS ((__vo uint32_t*)0xE000E400)


/************************************************************************************************************/

//base address of SRAM and FLASH
#define SRAM1_BASE_ADDR  0x20000000U//S ram base address found in
#define FLASH_BASE_ADDR  0x08000000U //flash base address found in rm p45 embedded flash memory interface
#define SRAM             SRAM1_BASE_ADDR //SRAM1 is the only s ram so SRAM1_BASE_ADDR = SRAM
#define ROM              0x1FFF0000U //Flash address for system memory we cannot change anything in here found in pg45 rmf



//base address of peripherals
#define PERIPH_BASE            0X40000000U //found in memory map in pg number 38 rm memory map
#define APB1_PERIPHERAL_BASE   PERIPH_BASE//found in memory map in pg number 38 rm memory map same for all the other below
#define APB2_PERIPHERAL_BASE   0X40010000U
#define AHB1_PERIPHERAL_BASE   0x40020000U
#define AHB2_PERIPHERAL_BASE   0x50000000U


// Base address of the peripherals which are hanging on the AHB1 bus
#define GPIOA_BASE_ADDRESS            (AHB1_PERIPHERAL_BASE)
#define GPIOB_BASE_ADDRESS            ((AHB1_PERIPHERAL_BASE)+(0X00000400))      //these are found in  the memory map of the rm pg no 38
#define GPIOC_BASE_ADDRESS            ((AHB1_PERIPHERAL_BASE)+(0X00000800))
#define GPIOD_BASE_ADDRESS            ((AHB1_PERIPHERAL_BASE)+(0X00000C00))
#define GPIOE_BASE_ADDRESS            ((AHB1_PERIPHERAL_BASE)+(0X00001000))
#define GPIOH_BASE_ADDRESS            ((AHB1_PERIPHERAL_BASE)+(0X00001C00))
#define CRC_BASE_ADDRESS              ((AHB1_PERIPHERAL_BASE)+(0X00003000))
#define RCC_BASE_ADDRESS              ((AHB1_PERIPHERAL_BASE)+(0X00003800))
#define FLASH_INTERFACE_BASE_ADDRESS  ((AHB1_PERIPHERAL_BASE)+(0X00003800))
#define DMA1_BASE_ADDRESS             ((AHB1_PERIPHERAL_BASE)+(0X00006000))
#define DMA2_BASE_ADDRESS             ((AHB1_PERIPHERAL_BASE)+(0X00006400))





//base address of the peripherals hanging on the AHB2 Bus

#define USB_OTG_BASE_ADDRESS                    AHB2_PERIPHERAL_BASE



//base address of the peripherals hanging on the APB1 Bus
#define TIM2_BASE_ADDRESS                APB1_PERIPHERAL_BASE
#define TIM3_BASE_ADDRESS                ((APB1_PERIPHERAL_BASE)+(0X00000400))
#define TIM4_BASE_ADDRESS                ((APB1_PERIPHERAL_BASE)+(0X00000800))
#define TIM5_BASE_ADDRESS                ((APB1_PERIPHERAL_BASE)+(0X00000C00))
#define RTC_AND_BKP_BASE_ADDRESS         ((APB1_PERIPHERAL_BASE)+(0x00002800))
#define WWDG_BASE_ADDRESS                ((APB1_PERIPHERAL_BASE)+(0X00002C00))
#define IWDG_BASE_ADDRESS                ((APB1_PERIPHERAL_BASE)+(0X00003000))
#define I2S2EXT_BASE_ADDRESS             ((APB1_PERIPHERAL_BASE)+(0X00003400))
#define SPI2_AND_I2S2_BASE_ADDRESS       ((APB1_PERIPHERAL_BASE)+(0X00003800))
#define SPI3_AND_I2S3_BASE_ADDRESS       ((APB1_PERIPHERAL_BASE)+(0X00003C00))
#define I2S3EXT_BASE_ADDRESS             ((APB1_PERIPHERAL_BASE)+(0X00004000))
#define USART2_BASE_ADDRESS              ((APB1_PERIPHERAL_BASE)+(0X00004400))
#define I2C1_BASE_ADDRESS                ((APB1_PERIPHERAL_BASE)+(0X00005400))
#define I2C2_BASE_ADDRESS                ((APB1_PERIPHERAL_BASE)+(0X00005800))
#define I2C3_BASE_ADDRESS                ((APB1_PERIPHERAL_BASE)+(0X00005C00))
#define PWR_BASE_ADDRESS                 ((APB1_PERIPHERAL_BASE)+(0X00007000))



//base address of the peripherals hanging on the APB2 Bus
#define TIM1_BASE_ADDRESS             APB2_PERIPHERAL_BASE
#define USART1_BASE_ADDRESS           ((APB2_PERIPHERAL_BASE)+(0X00001000))
#define USART6_BASE_ADDRESS           ((APB2_PERIPHERAL_BASE)+(0X00001400))
#define ADC1_BASE_ADDRESS             ((APB2_PERIPHERAL_BASE)+(0X00002000))
#define SDIO_BASE_ADDRESS             ((APB2_PERIPHERAL_BASE)+(0X00002C00))
#define SPI1_BASE_ADDRESS             ((APB2_PERIPHERAL_BASE)+(0X00003000))
#define SPI4_BASE_ADDRESS             ((APB2_PERIPHERAL_BASE)+(0X00003400))
#define SYSCONFIG_BASE_ADDRESS        ((APB2_PERIPHERAL_BASE)+(0X00003800))
#define EXTI_BASE_ADDRESS             ((APB2_PERIPHERAL_BASE)+(0X00003C00))
#define TIM9_BASE_ADDRESS             ((APB2_PERIPHERAL_BASE)+(0X00004000))
#define TIM1O_BASE_ADDRESS            ((APB2_PERIPHERAL_BASE)+(0X00004400))
#define TIM11_BASE_ADDRESS            ((APB2_PERIPHERAL_BASE)+(0X00004800))






/*
 * registers of a peripheral are specific to MCU
 * eg no of registers of SPI peripheral of stm32F401RE may be different than the SPI peripheral of STM32M01
 *
 */


/*
 * *****************************RCC Register macros and  definitions*******************
 */


/*
 * to Initialize the clock we will define a structure and then create variables inside the structure to hold the values of the clock to be  initialized
 * peripheral definition structure for RCC
 */


typedef struct
{
	__vo uint32_t CR;
	__vo uint32_t PLLCFGR;
	__vo uint32_t CFGR;
	__vo uint32_t CIR;
	__vo uint32_t AHB1RSTR;
	__vo uint32_t AHB2RSTR;
	uint32_t RESERVED1[2];
    __vo uint32_t APB1RSTR;
    __vo uint32_t APB2RSTR;
	uint32_t RESERVED2[2];
	__vo uint32_t AHB1ENR;
	__vo uint32_t AHB2ENR;
	uint32_t RESERVED3[2];
	__vo uint32_t APB1ENR;
	__vo uint32_t APB2ENR;
	uint32_t RESERVED4[2];
	__vo uint32_t AHB1LPENR;
	__vo uint32_t AHB2LPENR;
	uint32_t RESERVED5[2];
	__vo uint32_t APB1LPENR;
	__vo uint32_t APB2LPENR;
	uint32_t RESERVED6[2];
	__vo uint32_t BDCR;
	__vo uint32_t CSR;
	uint32_t RESERVED7[2];
	__vo uint32_t SSCGR;
	__vo uint32_t PLLI2SCFGR;
	__vo uint32_t DCKCFGR;

}RCC_register_definition_t;


/*
 * RCC AHB1 peripheral reset register (RCC_AHB1RSTR)
 * register reset macros from rm pg no 112
 * this is used to clear the whole port and peripherals by a single value
 * 1 to reset the whole register and 0 to not change anything
 */

//RCC Base address type casted to the structure(RCC_register_definition_t)
#define RCC ((RCC_register_definition_t*)RCC_BASE_ADDRESS)

/*
 * *******************************************************************************************************
 */

/*
 * *******************************************EXTI register definitions******************************
 */

/*
 * Peripheral definition structure for EXTI
 *   rm pg209
 */
typedef struct{
	__vo uint32_t IMR;   //Interrupt mask register                         ADDRESS OFFSET 0X00
	__vo uint32_t EMR;   //Event mask register                             ADDRESS OFFSET 0X04
	__vo uint32_t RTSR;  //Rising trigger selection register               ADDRESS OFFSET 0X08
	__vo uint32_t FTSR;  //Falling trigger selection register              ADDRESS OFFSET 0X0C
	__vo uint32_t SWIER; //Software interrupt event register               ADDRESS OFFSET 0X10
	__vo uint32_t PR;    //Pending Register                                ADDRESS OFFSET 0X14
}EXTI_Register_definition_t;

//EXTI Base address type casted to the structure (EXTI_register_definition_t)
#define EXTI ((EXTI_Register_definition_t*)EXTI_BASE_ADDRESS)


/*
 *IRQ numbers of different  interrupt request number(Position present the vector table of rm pg no 203)
 *
 */
#define IRQ_NO_EXTI0     6
#define IRQ_NO_EXTI1     7
#define IRQ_NO_EXTI2     8
#define IRQ_NO_EXTI3     9
#define IRQ_NO_EXTI4     10
#define IRQ_NO_EXTI9_5   23
#define IRQ_NO_EXTI15_10 40

/*
 * macros of different priority values of the interrupt
 */
#define IRQ_PRIO0  0
#define IRQ_PRIO1  1
#define IRQ_PRIO2  2
#define IRQ_PRIO3  3
#define IRQ_PRIO4  4
#define IRQ_PRIO5  5
#define IRQ_PRIO6  6
#define IRQ_PRIO7  7
#define IRQ_PRIO8  8
#define IRQ_PRIO9  9
#define IRQ_PRIO10 10
#define IRQ_PRIO11 11
#define IRQ_PRIO12 12
#define IRQ_PRIO13 13
#define IRQ_PRIO14 14
#define IRQ_PRIO15 15
/*
 * *************************************************************************************************************************
 */


/*
 * ****************************************SYSCONFIG register definitions**************************************************
 */
/*
 * peripheral definition structure for SYSCONFIG register(system configuration controller)
 *  RM PAGE NO 140
 *  EXTI  interrupt registers there are four of them and if we want the pin 0 to 3 give an interrupt use exticr1
 *  4 to 7 exticr2 and same and to initialize each port we will be using the 4 digit values given
 */
typedef struct{
	__vo uint32_t MEMRMP;   //memory remap register                        ADDRESS OFFSET 0X00
	__vo uint32_t PMC;      //peripheral mode configuration register       ADDRESS OFFSET 0X04
	__vo uint32_t EXTICR[4];  //External Interrupt configuration register there are 4 exti cr registers cr1 2 3,4    ADDRESS OFFSET 0X08
	uint32_t RESERVED [2];
	__vo uint32_t CMPCR;    //Compensation cell control register           ADDRESS OFFSET 0X20
}sysconfig_register_definition_t;



//SYSCONFIG base address type casted to the structure (sysconfig_register_definition_t)
#define SYSCONFIG ((sysconfig_register_definition_t*)SYSCONFIG_BASE_ADDRESS)
//clock enable macros for Sysconfig registers
#define SYSCONFIG_PCLK_EN() (RCC->APB2ENR|=(1<<14)) //to enable SYSCONFIG peripheral clock
//clock disable macros for Sysconfig registers
#define SYSCONFIG_PCLK_DI() (RCC->APB2ENR&=~(1<<14)) //to disable SYSCONFIG peripheral clock
/*
 * *****************************************************************************************************************************************
 */

/*
 **************************** GPIO Peripheral API and Macros ********************
 */


/*took this from the register map under gpio at pg no 164 to according to the address and then used
that to set he registers lecture number 84
then using the rcc registers named them so these registers tell the Gpio port how they should behave
*/
typedef struct
{
	__vo uint32_t MODER;   //GPIO port mode register
	__vo uint32_t OTYPER;  //GPIO port output type register
	__vo uint32_t OSPEEDR; //GPIO port output speed register
	__vo uint32_t PUPDR;   //GPIO port pull-up/pull-down register
	__vo uint32_t IDR;     //GPIO port input data register
	__vo uint32_t ODR ;    //GPIO port output data register
	__vo uint32_t BSRR;    //GPIO port bit set/reset register
	__vo uint32_t LCKR;    //GPIO port configuration lock register

	//we have 2 alternate function registers in here so instead of creating two variables we created an array,
	__vo uint32_t AFR[2];	//AFR[0]=alternate function low register,AFR[1]=alternate function high register
}GPIO_Register_Definition_t;
/*
 * peripheral base address type casted to the structure( GPIO_Register_Definition_t)
 */

#define GPIOA ((GPIO_Register_Definition_t*)GPIOA_BASE_ADDRESS)
#define GPIOB ((GPIO_Register_Definition_t*)GPIOB_BASE_ADDRESS)
#define GPIOC ((GPIO_Register_Definition_t*)GPIOC_BASE_ADDRESS)
#define GPIOD ((GPIO_Register_Definition_t*)GPIOD_BASE_ADDRESS)
#define GPIOE ((GPIO_Register_Definition_t*)GPIOE_BASE_ADDRESS)
#define GPIOH ((GPIO_Register_Definition_t*)GPIOH_BASE_ADDRESS)


//clock enable macros for GPIO peripherals
#define GPIOA_PCLK_EN() (RCC->AHB1ENR|=(1<<0)) //to enable GPIOA peripheral clock
#define GPIOB_PCLK_EN() (RCC->AHB1ENR|=(1<<1)) //to enable GPIOB peripheral clock
#define GPIOC_PCLK_EN() (RCC->AHB1ENR|=(1<<2)) //to enable GPIOC peripheral clock
#define GPIOD_PCLK_EN() (RCC->AHB1ENR|=(1<<3)) //to enable GPIOD peripheral clock
#define GPIOE_PCLK_EN() (RCC->AHB1ENR|=(1<<4)) //to enable GPIOE peripheral clock
#define GPIOH_PCLK_EN() (RCC->AHB1ENR|=(1<<5)) //to enable GPIOH peripheral clock
//clock disable registers for GPIO peripherals
#define GPIOA_PCLK_DI() (RCC->AHB1ENR&=~(1<<0)) //to disable GPIOA peripheral clock
#define GPIOB_PCLK_DI() (RCC->AHB1ENR&=~(1<<1)) //to disable GPIOB peripheral clock
#define GPIOC_PCLK_DI() (RCC->AHB1ENR&=~(1<<2)) //to disable GPIOC peripheral clock
#define GPIOD_PCLK_DI() (RCC->AHB1ENR&=~(1<<3)) //to disable GPIOD peripheral clock
#define GPIOE_PCLK_DI() (RCC->AHB1ENR&=~(1<<4)) //to disable GPIOE peripheral clock
#define GPIOH_PCLK_DI() (RCC->AHB1ENR&=~(1<<5)) //to disable GPIOH peripheral clock
/*Macros to reset GPIOx peripherals
 * when AHB RSTR is 1 it will reset the whole port where it is 1
 * so after resetting the whole port rcc registers we have to turn it back into 0 so that it will execute it once and stop
 * otherwise it will continue to reset the whole port continuously
 */
#define GPIOA_REG_RESET()  do{(RCC->AHB1RSTR|=(1<<0));  ((RCC->AHB1RSTR)&=~(1<<0));}while(0) //will reset the whole port A
#define GPIOB_REG_RESET()  do{(RCC->AHB1RSTR|=(1<<1)); (RCC->AHB1RSTR&=~(1<<1));}while(0)    //will reset the whole port B
#define GPIOC_REG_RESET()  do{(RCC->AHB1RSTR|=(1<<2)); (RCC->AHB1RSTR&=~(1<<2));}while(0)    //will reset the whole port C
#define GPIOD_REG_RESET()  do{(RCC->AHB1RSTR|=(1<<3)); (RCC->AHB1RSTR&=~(1<<3));}while(0)    //will reset the whole port D
#define GPIOE_REG_RESET()  do{(RCC->AHB1RSTR|=(1<<4)); (RCC->AHB1RSTR&=~(1<<4));}while(0)    //will reset the whole port E /
#define GPIOH_REG_RESET()  do{(RCC->AHB1RSTR|=(1<<7)); (RCC->AHB1RSTR&=~(1<<7));}while(0)    //will reset the whole port H



/*
 * returns port code for given GPIOx base address
 *ternary or conditional operator lecture no 111
 */
#define GPIO_BASE_ADDR_TO_CODE(x)      ((x==GPIOA)?0:\
		                                (x==GPIOB)?1:\
				                        (x==GPIOC)?2:\
						                (x==GPIOD)?3:\
								        (x==GPIOE)?4:\
										(x==GPIOH)?7:0)


/*
 * **************************** SPI Peripheral**************************************************
 */
/*
 * peripheral definition structure of spi
 * we have to arrange each of the registers according to the memory assigned
 * pg no601
 */
typedef struct{
	__vo uint32_t CR1;//SPI control register 1 ADDRESS OFFSET 0X00
	__vo uint32_t CR2;//SPI control register 2 ADDRESS OFFSET 0X04
	__vo uint32_t SR;//SPI status register     ADDRESS OFFSET 0X08
	__vo uint32_t DR;//SPI Data register       ADDRESS OFFSET 0X0C
	__vo uint32_t CRPCPR;//SPI cyclic redundancy check polynomial register ADDRESS OFFSET 0X10
	__vo uint32_t RXCRC;//SPI receiver crc register ADDRESS OFFSET 0X14
	__vo uint32_t TXCRC;//SPI transmitter crc register ADDRESS OFFSET 0X18
	__vo uint32_t CFGR;//used to configure whether to use spi or i2c ADDRESS OFFSET 0X1C
	__vo uint32_t PR;//prescalar register we use it slow down speed for some slaves
}SPI_periph_defn_t;

/*
 * Configuration structure for spix peripherals
 */
typedef struct{
	__vo uint32_t SPI_dev_md;//(SPI device mode) to set whether the device will be working as a master or slave
	__vo uint32_t SPI_bus_cnfg;//(SPI bus Config) to set whether the master and slave will work in simplex, full dup[lex or duplex mode
	__vo uint32_t SPI_dff;//(SPI data frame format:at a time how many data we want to send whether 8 bits or 16 bits usually 8bits
	__vo uint32_t SPI_CPHA;//SPI clock phase:whether the data read should happen in the first clock signal or the second default set to 0
	__vo uint32_t SPI_CPOL;//SPI clock polarity:so during the stable state whethner clock should be zero or 1 bny default it is 0
	__vo uint32_t SPI_ssm;//SPI slave select management: when a slave is pulled to low it will kknow that the master is trying to connect
	__vo uint32_t SPI_speed;//spi speed if for serial clock speed can have a maximum speed of 8MHz through HSI we can change that through PLL and HSE though
}SPI_config_t;

/*
 * SPI dev mode configuration macros
 */
#define SPI_DEV_MASTER 1 //the device will work in master mode
#define SPI_DEV_SLAVE  0 //the device will work in slave mode

/*
 * SPI bus configuration macros
 */
#define SPI_BUS_CONFIG_FD 1 //both master and slave communication will be through full duplex
#define SPI_BUS_CONFIG_HD 2 //both master and slave communication will be through half duplex
//we did not use simplex transmitter is because it is basicallt full duplex but the receive line that is miso is not configured
#define SPI_BUS_CONFIG_SIMPLEX_RX 3//master and slave will have only one connection all the time and only slave can send data

/*
 * SPI data frame formate 8 bits or 16 bits by default 8 bits
 */
#define SPI_DFF_8BITS 0
#define SPI_DFF_16BITS 1

/*
 * SPI clock phase it will decide where the data should be captured first edge or the second.By default it is zero meaning the data is processed by both master and slave before any data is sent by
 * either of them or during the first edge of the system clk
 */
#define SPI_CPHA_LOW  0
#define SPI_CPHA_HIGH 1

/*
 * SPI clock polarity it will decide in the idle state should the signal be in logic low or high by default it is low
 */
#define SPI_CPOL_LOW 0
#define SPI_CPOL_HIGH 1

/*
 * SPI slave select management there are 2 modes software slave select or hardware slave select by default it is in hardware mode so if the SSM_EN is selected then the software slave select will work by
 * the inbuilt slave select management software and the ssm bit will be ground leading to that slave always on
 */
#define SPI_SSM_EN 1
#define SPI_SSM_DI 0



/*
 * SPI clock speed or sysclk speed definition
 * the clock speed is defined by the baud rate control and we have 8 modes that is the prescaler value
 * by default the spi can produce signal/2 that it receives either from hsi,hseor pll
 * so by using HSI the maximum clock we can generate is 8MHZ
 */
#define SPI_SCLK_DIV2 0 //when we set the BR register that is present in cr1 the serial clock is divided by 2 this is the default case
#define SPI_SCLK_DIV4 1 //when we set the BR register  the serial clock is divided by 4 that is the frequency at which the spi register would work at for the current setting
#define SPI_SCLK_DIV8 2 //when we set the BR register  the serial clock is divided by 8
#define SPI_SCLK_DIV16 3 //when we set the BR register  the serial clock is divided by 16
#define SPI_SCLK_DIV32 4 //when we set the BR register  the serial clock is divided by 32
#define SPI_SCLK_DIV64 5 //when we set the BR register  the serial clock is divided by 64
#define SPI_SCLK_DIV128 6 //when we set the BR register  the serial clock is divided by 128
#define SPI_SCLK_DIV256 7 //when we set the BR register  the serial clock is divided by 256

//SPI base address typecasted to the structure (SPI_periph_defn_t)
#define SPI1 ((SPI_periph_defn_t*)SPI1_BASE_ADDRESS)
#define SPI2 ((SPI_periph_defn_t*)SPI2_AND_I2S2_BASE_ADDRESS)
#define SPI3 ((SPI_periph_defn_t*)SPI3_AND_I2S3_BASE_ADDRESS)
#define SPI4 ((SPI_periph_defn_t*)SPI4_BASE_ADDRESS)


//clock enable macros for the SPI peripherals
#define SPI1_PCLK_EN() (RCC->APB2ENR|=(1<<12)) //to enable SPI1 peripheral clock
#define SPI2_PCLK_EN() (RCC->APB1ENR|=(1<<14)) //to enable SPI2 peripheral clock
#define SPI3_PCLK_EN() (RCC->APB1ENR|=(1<<15)) //to enable SPI3 peripheral clock
#define SPI4_PCLK_EN() (RCC->APB2ENR|=(1<<13)) //to enable SPI4 peripheral clock

//clock disable macros for the SPI peripherals
#define SPI1_PCLK_DI() (RCC->APB2ENR&=~(1<<12)) //to disable SPI1 peripheral clock
#define SPI2_PCLK_DI() (RCC->APB1ENR&=~(1<<14)) //to disable SPI2 peripheral clock
#define SPI3_PCLK_DI() (RCC->APB1ENR&=~(1<<15)) //to disable SPI3 peripheral clock
#define SPI4_PCLK_DI() (RCC->APB2ENR&=~(1<<13)) //to disable SPI4 peripheral clock

/*
 * Macros to reset SPI peripherals
 * when AHB RSTR is 1 it will reset the whole port where it is 1
 * so after resetting the whole port rcc registers we have to turn it back into 0 so that it will execute it once and stop
 * otherwise it will continue to reset the whole port continuously
 */
#define SPI1_REG_RESET()  do{(RCC->APB2RSTR|=(1<<12)); (RCC->APB2RSTR&=~(1<<12));}while(0) //will reset the whole SPI 1 peripheral
#define SPI2_REG_RESET()  do{(RCC->APB1RSTR|=(1<<14)); (RCC->APB1RSTR&=~(1<<14));}while(0) //will reset the whole SPI 2 peripheral
#define SPI3_REG_RESET()  do{(RCC->APB1RSTR|=(1<<15)); (RCC->APB1RSTR&=~(1<<15));}while(0) //will reset the whole SPI 3 peripheral
#define SPI4_REG_RESET()  do{(RCC->APB2RSTR|=(1<<13)); (RCC->APB2RSTR&=~(1<<13));}while(0) //will reset the whole SPI 4 peripheral

/*
 * we have defined a macro here to set the txe register and we are using this macro to verify whether data is present in the txe register when we want to send
 * data, it is implemented at the while loop in spi_send_data function
 */
#define SPI_TXE_FLAG  |=(1<<1)

/*
 * bit position values of spi cr1 register these macros are used to store the pin number that we use in the spi_driver.c
 * we give the macros because it will be easier for us to decode if any errors occur and if someone else sees this code then easier for them to understand it
 */
#define SPI_CR1_CPHA      0
#define SPI_CR1_CPOL      1
#define SPI_CR1_MSTR      2
#define SPI_CR1_BR        3
#define SPI_CR1_SPE       6
#define SPI_CR1_LSBFIRST  7
#define SPI_CR1_SSI       8
#define SPI_CR1_SSM       9
#define SPI_CR1_RXONLY    10
#define SPI_CR1_DFF       11
#define SPI_CR1_CRCNEXT   12
#define SPI_CR1_CRCEN     13
#define SPI_CR1_BIDIOE    14
#define SPI_CR1_BIDIMODE  15


/*
 * *************************************************************************************************************************************
 */

//clock enable macros for the I2cx peripherals
#define I2C1_PCLK_EN() (RCC->APB1ENR|=(1<<21)) //to enable I2C1 peripheral clock
#define I2C2_PCLK_EN() (RCC->APB1ENR|=(1<<22)) //to enable I2C2 peripheral clock
#define I2C3_PCLK_EN() (RCC->APB1ENR|=(1<<23)) //to enable I2C2 peripheral clock


//clock enable macros for USART Peripherals
#define USART1_PCLK_EN() (RCC->APB2ENR|=(1<<4)) //to enable USART1 peripheral clock
#define USART6_PCLK_EN() (RCC->APB2ENR|=(1<<5)) //to enable USART6 peripheral clock
#define USART2_PCLK_EN() (RCC->APB1ENR|=(1<<17)) //to enable USART2 peripheral clock





//clock disable registers for I2Cx peripherals
#define I2C1_PCLK_DI() (RCC->APB1ENR&=~(1<<21)) //to disable I2C1 peripheral clock
#define I2C2_PCLK_DI() (RCC->APB1ENR&=~(1<<22)) //to disable I2C2 peripheral clock
#define I2C3_PCLK_DI() (RCC->APB1ENR&=~(1<<23)) //to disable I2C2 peripheral clock


//clock disable macros for USART Peripherals
#define USART1_PCLK_DI() (RCC->APB2ENR&=~(1<<4))  //to disable USART1 peripheral clock
#define USART6_PCLK_DI() (RCC->APB2ENR&=~(1<<5))  //to disable USART6 peripheral clock
#define USART2_PCLK_DI() (RCC->APB1ENR&=~(1<<17)) //to disable USART2 peripheral clock







//enable or disable
#define ENABLE           1
#define DISABLE          0
#define SET              ENABLE
#define RESET            DISABLE
#define GPIO_PIN_SET     SET
#define GPIO_PIN_RESET   RESET
#define SPI_FLAG_SET     SET
#define SPI_FLAG_RESET   RESET




#endif /* INC_STM32F401XX_H_ */
